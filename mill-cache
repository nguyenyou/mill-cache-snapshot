#!/bin/bash
set -euo pipefail

# Config
CACHE_ROOT="$HOME/.mill-out-cache"
MAX_SNAPSHOTS=10
MAX_SIZE_GB=50
MAIN_BRANCH="master"
DEBUG=${DEBUG:-1}
GC_TARGET_DIR="/Users/tunguyen/work/stargazer"

debug() {
  [[ "$DEBUG" == "1" ]] && echo -e "${YELLOW}[debug]${NC} $*"
}

# Spinner with elapsed time - runs until background job completes
spin_while() {
  local pid=$1
  local msg=$2
  local spinchars='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
  local i=0
  local start=$(date +%s)

  # Hide cursor
  tput civis 2>/dev/null || true

  while kill -0 "$pid" 2>/dev/null; do
    local elapsed=$(($(date +%s) - start))
    local spin=${spinchars:i%${#spinchars}:1}
    printf "\r${CYAN}%s${NC} %s ${YELLOW}%ds${NC}  " "$spin" "$msg" "$elapsed"
    ((i++))
    sleep 0.1
  done

  # Show cursor, clear line
  tput cnorm 2>/dev/null || true
  printf "\r\033[K"

  # Return the exit status of the background process
  wait "$pid"
}

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
NC='\033[0m'

get_project_name() {
  # Try git remote first
  local remote=$(git remote get-url origin 2>/dev/null || echo "")
  if [[ -n "$remote" ]]; then
    # Extract repo name from URL (handles both https and ssh)
    basename -s .git "$remote"
  else
    # Fallback to directory name
    basename "$(git rev-parse --show-toplevel)"
  fi
}

PROJECT_NAME=$(get_project_name)
CACHE_DIR="$CACHE_ROOT/$PROJECT_NAME"

ensure_main_branch() {
  debug "ensure_main_branch: checking current branch"
  local current=$(git rev-parse --abbrev-ref HEAD)
  debug "ensure_main_branch: current='$current', required='$MAIN_BRANCH'"
  if [[ "$current" != "$MAIN_BRANCH" ]]; then
    echo -e "${RED}Error: Must be on '$MAIN_BRANCH' branch (currently on '$current')${NC}"
    exit 1
  fi
  debug "ensure_main_branch: OK"
}

sync_upstream() {
  debug "sync_upstream: fetching upstream/$MAIN_BRANCH"
  echo -e "${CYAN}Syncing with upstream/$MAIN_BRANCH...${NC}"
  if ! git fetch upstream "$MAIN_BRANCH"; then
    echo -e "${RED}Error: Failed to fetch upstream/$MAIN_BRANCH${NC}"
    exit 1
  fi
  debug "sync_upstream: rebasing onto upstream/$MAIN_BRANCH"
  if ! git rebase "upstream/$MAIN_BRANCH" "$MAIN_BRANCH"; then
    echo -e "${RED}Error: Failed to rebase on upstream/$MAIN_BRANCH${NC}"
    git rebase --abort 2>/dev/null || true
    exit 1
  fi
  debug "sync_upstream: complete"
  echo -e "${GREEN}Synced to upstream/$MAIN_BRANCH${NC}"
  echo ""
}

ensure_clean_worktree() {
  debug "ensure_clean_worktree: checking for unstaged changes"
  if ! git diff --quiet; then
    echo -e "${RED}Error: Unstaged changes present${NC}"
    git status --short
    exit 1
  fi

  debug "ensure_clean_worktree: checking for staged changes"
  if ! git diff --cached --quiet; then
    echo -e "${RED}Error: Staged uncommitted changes present${NC}"
    git status --short
    exit 1
  fi

  # Check for untracked files in src dirs (optional, stricter)
  debug "ensure_clean_worktree: checking for untracked files"
  local untracked=$(git ls-files --others --exclude-standard | grep -v '^out/' | head -5)
  if [[ -n "$untracked" ]]; then
    echo -e "${YELLOW}Warning: Untracked files present (ignored):${NC}"
    echo "$untracked"
  fi
  debug "ensure_clean_worktree: OK"
}

get_cache_size_gb() {
  du -sg "$CACHE_DIR" 2>/dev/null | cut -f1 || echo 0
}

get_snapshot_count() {
  find "$CACHE_DIR" -maxdepth 1 -type d -name '[a-f0-9]*' 2>/dev/null | wc -l | tr -d ' '
}

prune_oldest() {
  local reason=$1
  local oldest=$(ls -1t "$CACHE_DIR" | grep -v index.txt | tail -1)
  if [[ -n "$oldest" ]]; then
    echo -e "${YELLOW}Pruning oldest snapshot ($reason): ${oldest:0:7}${NC}"
    rm -rf "$CACHE_DIR/$oldest"
    sed -i '' "/^$oldest/d" "$CACHE_DIR/index.txt" 2>/dev/null || true
  fi
}

enforce_limits() {
  debug "enforce_limits: checking snapshot count (max=$MAX_SNAPSHOTS)"
  while (( $(get_snapshot_count) > MAX_SNAPSHOTS )); do
    prune_oldest "count > $MAX_SNAPSHOTS"
  done

  debug "enforce_limits: checking cache size (max=${MAX_SIZE_GB}GB)"
  while (( $(get_cache_size_gb) > MAX_SIZE_GB )); do
    prune_oldest "size > ${MAX_SIZE_GB}GB"
  done
  debug "enforce_limits: done"
}

compile() {
  debug "compile: starting ./mill __.compile"
  echo -e "${CYAN}Running ./mill __.compile ...${NC}"
  echo ""

  if ! ./mill __.compile; then
    echo -e "${RED}Error: Compilation failed, aborting snapshot${NC}"
    exit 1
  fi

  debug "compile: successful"
  echo ""
  echo -e "${GREEN}Compilation successful${NC}"
}

snapshot() {
  debug "snapshot: starting for project=$PROJECT_NAME"
  ensure_main_branch
  ensure_clean_worktree
  sync_upstream

  local hash=$(git rev-parse HEAD)
  local short=$(git rev-parse --short HEAD)
  local dest="$CACHE_DIR/$hash"
  debug "snapshot: hash=$short, dest=$dest"

  if [[ -d "$dest" ]]; then
    debug "snapshot: already exists, skipping"
    echo -e "${YELLOW}Snapshot already exists for $short${NC}"
    status
    return 0
  fi

  # Compile before snapshot
  compile

  if [[ ! -d out ]]; then
    echo -e "${RED}Error: No 'out' directory after compile${NC}"
    exit 1
  fi

  debug "snapshot: creating cache dir $CACHE_DIR"
  mkdir -p "$CACHE_DIR"

  echo ""
  debug "snapshot: cloning out/ to $dest"
  cp -rc out "$dest" &
  local cp_pid=$!
  spin_while "$cp_pid" "Snapshotting $short..."

  # Update index
  debug "snapshot: updating index.txt"
  echo "$hash $(date -Iseconds) $(du -sh "$dest" | cut -f1)" >> "$CACHE_DIR/index.txt"

  enforce_limits

  debug "snapshot: complete"
  echo -e "${GREEN}Snapshot created: $short${NC}"
  status
}

restore() {
  local target=$1
  debug "restore called with target='$target'"

  if [[ -z "$target" ]]; then
    debug "no target specified, searching git history for cached snapshot"
    for h in $(git log --format=%H "$MAIN_BRANCH" 2>/dev/null); do
      if [[ -d "$CACHE_DIR/$h" ]]; then
        target=$h
        break
      fi
    done
    debug "found target from history: ${target:-none}"

    if [[ -z "$target" ]]; then
      echo -e "${RED}Error: No cached snapshot found in commit history${NC}"
      list
      exit 1
    fi
  fi

  # Allow partial hash match
  if [[ -n "$target" && ${#target} -lt 40 ]]; then
    debug "partial hash provided, searching for match: $target*"
    local match=$(find "$CACHE_DIR" -maxdepth 1 -type d -name "${target}*" | head -1)
    debug "match result: ${match:-none}"
    if [[ -n "$match" ]]; then
      target=$(basename "$match")
      debug "resolved to full hash: $target"
    else
      echo -e "${RED}Error: No snapshot matching '$target'${NC}"
      list
      exit 1
    fi
  fi

  if [[ -z "$target" || ! -d "$CACHE_DIR/$target" ]]; then
    echo -e "${RED}Error: No cached snapshot found${NC}"
    list
    exit 1
  fi

  debug "restoring from: $CACHE_DIR/$target"

  local start_time=$(date +%s.%N)

  # Move old out/ aside for GC (if exists)
  if [[ -d out ]]; then
    local old_dir="out.old.$$"
    debug "moving current out/ to $old_dir"
    mv out "$old_dir"
  fi

  debug "cloning snapshot to out/"
  # Run cp in background with spinner
  cp -rc "$CACHE_DIR/$target" out &
  local cp_pid=$!
  spin_while "$cp_pid" "Restoring ${target:0:7}..."

  local end_time=$(date +%s.%N)
  local elapsed=$(echo "$end_time - $start_time" | bc)

  local short=${target:0:7}
  local msg=$(git log -1 --format=%s "$target" 2>/dev/null || echo "")
  debug "restore complete"
  echo -e "${GREEN}Restored${NC}: ${CYAN}$short${NC} - $msg"
  echo -e "  Time: ${YELLOW}${elapsed}s${NC}"
}

list() {
  debug "list: showing snapshots for project=$PROJECT_NAME"
  debug "list: cache_dir=$CACHE_DIR"
  echo ""
  echo -e "Cached snapshots for ${CYAN}$PROJECT_NAME${NC}:"
  echo "─────────────────────────────────────────────────────────────"

  if [[ -f "$CACHE_DIR/index.txt" ]]; then
    debug "list: reading index.txt"
    while read hash ts size; do
      local short=${hash:0:7}
      local msg=$(git log -1 --format=%s "$hash" 2>/dev/null || echo "???")
      msg=${msg:0:42}
      printf "  %s  %s  %5s  %s\n" "$short" "${ts:0:10}" "$size" "$msg"
    done < <(tac "$CACHE_DIR/index.txt")
  else
    debug "list: no index.txt found"
    echo "  (none)"
  fi

  echo "─────────────────────────────────────────────────────────────"
}

list_all() {
  debug "list_all: showing all projects in $CACHE_ROOT"
  echo ""
  echo "All cached projects:"
  echo "═════════════════════════════════════════════════════════════"

  for project_dir in "$CACHE_ROOT"/*/; do
    [[ ! -d "$project_dir" ]] && continue
    local proj=$(basename "$project_dir")
    debug "list_all: scanning project=$proj"
    local count=$(find "$project_dir" -maxdepth 1 -type d -name '[a-f0-9]*' 2>/dev/null | wc -l | tr -d ' ')
    local size=$(du -sh "$project_dir" 2>/dev/null | cut -f1 || echo "0")

    if [[ "$proj" == "$PROJECT_NAME" ]]; then
      printf "  ${CYAN}%-20s${NC}  %3s snapshots  %6s  (current)\n" "$proj" "$count" "$size"
    else
      printf "  %-20s  %3s snapshots  %6s\n" "$proj" "$count" "$size"
    fi
  done

  echo "═════════════════════════════════════════════════════════════"
  printf "  %-20s  %3s snapshots  %6s\n" "TOTAL" \
    "$(find "$CACHE_ROOT" -maxdepth 2 -type d -name '[a-f0-9]*' 2>/dev/null | wc -l | tr -d ' ')" \
    "$(du -sh "$CACHE_ROOT" 2>/dev/null | cut -f1 || echo 0)"
}

status() {
  debug "status: getting stats for project=$PROJECT_NAME"
  local count=$(get_snapshot_count)
  local size=$(du -sh "$CACHE_DIR" 2>/dev/null | cut -f1 || echo "0")
  debug "status: count=$count, size=$size"

  echo ""
  echo -e "${CYAN}Mill Out Cache${NC}: $PROJECT_NAME"
  echo "────────────────────────────────────"
  echo "  Location:   $CACHE_DIR"
  echo "  Snapshots:  $count / $MAX_SNAPSHOTS"
  echo "  Size:       $size / ${MAX_SIZE_GB}GB"
  echo ""
}

clean() {
  debug "clean: preparing to clean project=$PROJECT_NAME"
  debug "clean: target=$CACHE_DIR"
  echo "Current cache for $PROJECT_NAME:"
  status
  echo ""
  read -p "Delete ALL snapshots for $PROJECT_NAME? [y/N] " confirm
  if [[ "$confirm" == "y" ]]; then
    debug "clean: confirmed, removing $CACHE_DIR"
    rm -rf "$CACHE_DIR"
    echo -e "${GREEN}Cleaned $PROJECT_NAME cache.${NC}"
  else
    debug "clean: cancelled by user"
  fi
}

clean_all() {
  debug "clean_all: preparing to clean all projects"
  debug "clean_all: target=$CACHE_ROOT"
  list_all
  echo ""
  read -p "Delete ALL snapshots for ALL projects? [y/N] " confirm
  if [[ "$confirm" == "y" ]]; then
    debug "clean_all: confirmed, removing $CACHE_ROOT"
    rm -rf "$CACHE_ROOT"
    echo -e "${GREEN}Cleaned all caches.${NC}"
  else
    debug "clean_all: cancelled by user"
  fi
}

gc() {
  debug "gc: scanning for garbage in $GC_TARGET_DIR"
  local count=0
  local total_size=0

  # Find all out.old.* directories
  while IFS= read -r -d '' dir; do
    local size=$(du -sk "$dir" 2>/dev/null | cut -f1 || echo 0)
    debug "gc: removing $dir (${size}K)"
    rm -rf "$dir"
    ((count++))
    ((total_size += size))
  done < <(find "$GC_TARGET_DIR" -maxdepth 1 -type d -name 'out.old.*' -print0 2>/dev/null)

  if [[ $count -gt 0 ]]; then
    local size_mb=$((total_size / 1024))
    echo -e "${GREEN}GC: removed $count garbage dir(s), freed ${size_mb}MB${NC}"
  else
    debug "gc: no garbage found"
  fi
}

usage() {
  cat <<EOF
Mill out/ cache manager (APFS clone-based)

Current project: $PROJECT_NAME

Usage: $(basename "$0") <command>

Commands:
  snapshot, s       Compile and snapshot current out/ (main branch, clean only)
  restore, r        Restore nearest ancestor snapshot
  restore <hash>    Restore specific snapshot (partial hash OK)
  list, ls, l       List snapshots for current project
  list-all, la      List all projects and their snapshots
  status, st        Show cache stats for current project
  clean             Delete all snapshots for current project
  clean-all         Delete all snapshots for all projects
  gc                Garbage collect old out/ dirs from restore

Requirements for snapshot:
  - Must be on '$MAIN_BRANCH' branch
  - No uncommitted changes (staged or unstaged)
  - Syncs to upstream/$MAIN_BRANCH before snapshot
  - ./mill __.compile must succeed

Config:
  MAX_SNAPSHOTS=$MAX_SNAPSHOTS (per project)
  MAX_SIZE_GB=$MAX_SIZE_GB (per project)
  CACHE_ROOT=$CACHE_ROOT

Debug mode (on by default):
  DEBUG=0 $(basename "$0") restore    # disable verbose logging
EOF
}

case "${1:-}" in
  snapshot|s)   snapshot ;;
  restore|r)    restore "${2:-}" ;;
  list|ls|l)    list ;;
  list-all|la)  list_all ;;
  status|st)    status ;;
  clean)        clean ;;
  clean-all)    clean_all ;;
  gc)           gc ;;
  help|-h|--help) usage ;;
  *)            usage ;;
esac
